;
; good: get a karma score greater than the positive connection limit
; bad: achieve a karma score lower than the negative connection limit
;
; how many days to penalize bad senders
penalty_days = 1

; each IPs karma history is expired after this many days
; Note: this value is refreshed upon each connection. Frequent
; senders karma may never expire.
expire_days = 60

; Redis is our super-lightweight key/value store
[redis]
server_ip   = 127.0.0.1
server_port = 6379


; concurrency limits. Limit how many concurrent connections an IP can make.
; Caution: Using this *and* the rate_limit plugin may produce unexpected
;          results. Use one or the other.
; Comment out this block of settings to disable
[concurrency]
bad=1
neutral=2
good=10

; delay excess connections this many seconds before disconnecting
disconnect_delay=10

; maximum number of recipients allowed
[recipients]
bad=1
neutral=5
good=20


[thresholds]
; Be conservative to avoid false positives!
; the threshold below which a connection is considered bad
negative=-3
; score at which a connection is considered good
positive=2

; karma history = good - bad connections. To achieve a negative score,
; senders must send more bad than good messages. Is it worth getting
; 5 spam and 2 ham? Adjust this knob accordingly.
history_negative=-3


[spammy_tlds]
; award negative karma to spammy TLDs
; caution, awarding karma > msg_negative_limit may blacklist that TLD
info=-4
biz=-3
pw=-4
;tw=-3
;cl=-2
;br=-2
;fr=-2
;be=-2
;jp=-2
;no=-2
;se=-2
;sg=-2

;                           AWARDS
; karma can award points by inspecting connection objects, including notes
; saved by other plugins.
;
; syntax: lo.ca.tion[@uniq] = N [if condition VAL]
;
; location: an object or attribute in the connection or transaction object.
;           Use the transaction prefix to check only the transaction note.
; @uniq:  an alpha-numeric unique value, subject to .ini value restrictions
; N:      a numeric karma score to award: + to praise, - to smite
; VAL:    the value to use in the conditional match
;
; conditions:
;     if match          // performs a case insensitive regex match on VAL
;     if equals         // performs an === comparison
;     if gt             // performs a greater-than comparison
;     if lt             // performs a less-than comparison
;
;     if length lt      // Compares the length of arrays. Especially
;     if length gt      // useful for plugins that use note.js
;     if length equals
;
; Examples:
;
;  relaying = 1         // any true value in the object matches, +1 karma
;
;  notes.spamassassin.flag     =  1 if equals No  // same thing
;  notes.spamassassin.flag@No  =  1 if equals     // matches if flag===No
;  notes.spamassassin.flag@Yes = -3 if equals     // matches if flag===Yes
;  notes.spamassassin.flag@uniq= -3 if equals Yes // matches if flag===Yes
;
; The values on the left hand side of the = sign in an INI file must be unique.
; To have multiple awards based on a single object location, each must have a
; uniq name. Use an @ followed by unique letters and numbers.
;
;  notes.dnsbl.fail@0 = -1 if length gt     // smite -1 if listed on 1 dnsbls
;  notes.dnsbl.fail@1 = -3 if length gt     // smite -3 if listed on 2 dnsbls

[awards]
relaying               = 3
notes.auth_user        = 3
notes.fcrdns.fcrdns@0  = 1 if length gt 0
notes.headers.pass@3   = 1 if length gt 3
notes.bounce           = -3 if equals invalid

; user defined white/blacklists
notes.rdns_access@w    = 3 if equals white
notes.rdns_access@b    = -10 if equals black

; awards are cumulative, failing multiple DNSBLs adds up fast
notes.dnsbl.fail@0     = -1 if length gt 0
notes.dnsbl.fail@1     = -2 if length gt 1
notes.dnsbl.fail@2     = -3 if length gt 2
notes.dnsbl.fail@3     = -4 if length gt 3

; deliver to one nonexistent address, easy mistake. But more than that, in
; the same connection? Smells like phishing.
notes.qmail_deliverable.fail@0 = -1 if length gt 0
notes.qmail_deliverable.fail@1 = -3 if length gt 1
notes.qmail_deliverable.fail@3 = -5 if length gt 3

notes.fcrdns.fail@0        = -1 if length gt 0
notes.fcrdns.fail@1        = -2 if length gt 1
notes.fcrdns.no_rdns       = -2
; Be careful with ip_in_rdns. Companies like Amazon.com have IPs in MX name
notes.fcrdns.ip_in_rdns    = -1

; use SA results as karma awards (adjust N based on your SA accuracy rate)
notes.spamassassin.flag@No =  1 if equals No
notes.spamassassin.flag@Yes= -3 if equals Yes

; award karma for whitelisted addresses
notes.mail_from.access.pass= 10 if length gt 1
notes.mail_from.access.pass= 10 if length gt 1

; award smites for blacklisted addresses
notes.mail_from.access.fail= -10 if length gt 0
notes.rcpt_to.access.fail  = -10 if length gt 0

;   This is 99% reliable for my mail
;notes.geoip.distance@4 = -1 if gt 4000
;notes.geoip.distance@8 = -1 if gt 8000

;   this is very reliable as well
;notes.p0f.os_name@freebsd = 1 if match freebsd
;notes.p0f.os_name@windows = -1 if match windows

; SPF results: 1 = None, 2=Pass, 3=Fail, 4=SoftFail
;              5=Neutral, 6=Temperror, 7=Permerror
notes.spf_helo@3 = -3 if equals 3
notes.spf_helo@4 = -1 if equals 4
notes.spf_helo@6 = -1 if equals 6
notes.spf_helo@7 = -1 if equals 7
notes.spf_mail_result@3= -2 if equals 3
notes.spf_mail_result@4= -1 if equals 4
notes.spf_mail_result@6= -1 if equals 6
notes.spf_mail_result@7= -1 if equals 7
